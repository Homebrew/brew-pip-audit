[
  {
    "name": "certifi",
    "version": "2021.10.8",
    "vulns": [
      {
        "id": "GHSA-43fp-rhv2-5gv8",
        "fix_versions": [
          "2022.12.7"
        ],
        "description": "Certifi 2022.12.07 removes root certificates from \"TrustCor\" from the root store. These are in the process of being removed from Mozilla's trust store.  TrustCor's root certificates are being removed pursuant to an investigation prompted by media reporting that TrustCor's ownership also operated a business that produced spyware. Conclusions of Mozilla's investigation can be found [here](https://groups.google.com/a/mozilla.org/g/dev-security-policy/c/oxX69KFvsm4/m/yLohoVqtCgAJ)."
      }
    ]
  },
  {
    "name": "lxml",
    "version": "4.6.4",
    "vulns": [
      {
        "id": "PYSEC-2021-852",
        "fix_versions": [
          "4.6.5"
        ],
        "description": "lxml is a library for processing XML and HTML in the Python language. Prior to version 4.6.5, the HTML Cleaner in lxml.html lets certain crafted script content pass through, as well as script content in SVG files embedded using data URIs. Users that employ the HTML cleaner in a security relevant context should upgrade to lxml 4.6.5 to receive a patch. There are no known workarounds available."
      },
      {
        "id": "PYSEC-2022-230",
        "fix_versions": [
          "4.9.1"
        ],
        "description": "NULL Pointer Dereference allows attackers to cause a denial of service (or application crash). This only applies when lxml is used together with libxml2 2.9.10 through 2.9.14. libxml2 2.9.9 and earlier are not affected. It allows triggering crashes through forged input data, given a vulnerable code sequence in the application. The vulnerability is caused by the iterwalk function (also used by the canonicalize function). Such code shouldn't be in wide-spread use, given that parsing + iterwalk would usually be replaced with the more efficient iterparse function. However, an XML converter that serialises to C14N would also be vulnerable, for example, and there are legitimate use cases for this code sequence. If untrusted input is received (also remotely) and processed via iterwalk function, a crash can be triggered."
      }
    ]
  },
  {
    "name": "pycares",
    "version": "4.1.2",
    "vulns": [
      {
        "id": "GHSA-c58j-88f5-h53f",
        "fix_versions": [
          "4.2.0"
        ],
        "description": "### Impact  pycares versions < 4.2.0 are affected by [CVE-2021-3672](https://nvd.nist.gov/vuln/detail/CVE-2021-3672).  ### Patches  Update to version 4.2.0. "
      }
    ]
  },
  {
    "name": "ujson",
    "version": "4.3.0",
    "vulns": [
      {
        "id": "PYSEC-2022-25",
        "fix_versions": [
          "5.1.0"
        ],
        "description": "UltraJSON (aka ujson) through 5.1.0 has a stack-based buffer overflow in Buffer_AppendIndentUnchecked (called from encode). Exploitation can, for example, use a large amount of indentation."
      },
      {
        "id": "OSV-2021-955",
        "fix_versions": [],
        "description": "OSS-Fuzz report: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=36009  ``` Crash type: Stack-buffer-overflow WRITE 1 Crash state: Buffer_AppendIndentUnchecked encode encode ``` "
      },
      {
        "id": "GHSA-wpqr-jcpx-745r",
        "fix_versions": [
          "5.4.0"
        ],
        "description": "### Impact _What kind of vulnerability is it? Who is impacted?_  Anyone parsing JSON from an untrusted source is vulnerable.  JSON strings that contain escaped surrogate characters not part of a proper surrogate pair were decoded incorrectly. Besides corrupting strings, this allowed for potential key confusion and value overwriting in dictionaries.  Examples:  ```python # An unpaired high surrogate character is ignored. >>> ujson.loads(r'\"\\uD800\"') '' >>> ujson.loads(r'\"\\uD800hello\"') 'hello'  # An unpaired low surrogate character is preserved. >>> ujson.loads(r'\"\\uDC00\"') '\\udc00'  # A pair of surrogates with additional non surrogate characters pair up in spite of being invalid. >>> ujson.loads(r'\"\\uD800foo bar\\uDC00\"') 'foo bar\ud800\udc00' ```  ### Patches _Has the problem been patched? What versions should users upgrade to?_  Users should upgrade to UltraJSON 5.4.0.  From version 5.4.0, UltraJSON decodes lone surrogates in the same way as the standard library's `json` module does, preserving them in the parsed output:  ```python3 >>> ujson.loads(r'\"\\uD800\"') '\\ud800' >>> ujson.loads(r'\"\\uD800hello\"') '\\ud800hello' >>> ujson.loads(r'\"\\uDC00\"') '\\udc00' >>> ujson.loads(r'\"\\uD800foo bar\\uDC00\"') '\\ud800foo bar\\udc00' ```  ### Workarounds _Is there a way for users to fix or remediate the vulnerability without upgrading?_  Short of switching to an entirely different JSON library, there are no safe alternatives to upgrading.  ### For more information If you have any questions or comments about this advisory: * Open an issue in [UltraJSON](http://github.com/ultrajson/ultrajson/issues) "
      },
      {
        "id": "GHSA-fm67-cv37-96ff",
        "fix_versions": [
          "5.4.0"
        ],
        "description": "### Impact _What kind of vulnerability is it? Who is impacted?_  When an error occurs while reallocating the buffer for string decoding, the buffer gets freed twice.  Due to how UltraJSON uses the internal decoder, this double free is impossible to trigger from Python.  ### Patches _Has the problem been patched? What versions should users upgrade to?_  Users should upgrade to UltraJSON 5.4.0.  ### Workarounds _Is there a way for users to fix or remediate the vulnerability without upgrading?_  There is no workaround.  ### For more information If you have any questions or comments about this advisory: * Open an issue in [UltraJSON](http://github.com/ultrajson/ultrajson/issues) "
      }
    ]
  }
]